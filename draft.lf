target C {
    threading: false,
    build: "../scripts/build_nrf_unix.sh"   
};
import Glove from "lib/glove.lf"
import GyroAngle from "lib/GyroAngle.lf"
import ExponentialFilter from "lib/ExponentialFilter.lf"
import Tilt from "lib/Tilt.lf"
preamble {=
    #include "simple_ble.h"
    #include <ble_advdata.h>
    #include <math.h>
    #include <stdbool.h>
    #include <stdint.h>
    #include <stdio.h>
    #include "app_error.h"
    #include "app_timer.h"
    #include "nrf.h"
    #include "nrf_delay.h"
    #include "nrf_gpio.h"
    #include "nrf_log.h"
    #include "nrf_log_ctrl.h"
    #include "nrf_log_default_backends.h"
    #include "nrf_pwr_mgmt.h"
    #include "nrf_drv_spi.h"

    // sensors
    // #define Finger_1 NRF_GPIO_PIN_MAP(0, 13)
    // #define Finger_2 NRF_GPIO_PIN_MAP(0, 14)
    // #define Finger_3 NRF_GPIO_PIN_MAP(0, 15)
    // #define Finger_4 NRF_GPIO_PIN_MAP(0, 16)

    
    // Data structures needed for BLE.
    // See https://github.com/lab11/nrf52x-base/blob/master/lib/simple_ble/README.md

    // BLE Configuration specifies the MAC address and
    // intervals for advertising and connections.
    static simple_ble_config_t ble_config = {
            // MAC address: c0:98:e5:49:xx:xx
            // where the last two octets are given by the device_id below.
            .platform_id       = 0x49,   // The 4th octet in device BLE address.
            .device_id         = 0x0018, // TODO: replace with your lab bench number
            .adv_name          = "NRF_BOARD", // used in advertisements if there is room
            .adv_interval      = MSEC_TO_UNITS(100, UNIT_0_625_MS),
            .min_conn_interval = MSEC_TO_UNITS(100, UNIT_1_25_MS),
            .max_conn_interval = MSEC_TO_UNITS(200, UNIT_1_25_MS),
    };

    // Specify a unique ID for the ROMI service.
    // UUID: 85e43f4d-b4a7-4c6f-ba86-2db3c40a2c83
    static simple_ble_service_t my_service = {{
        .uuid128 = {0x83,0x2c,0x0a,0xc4,0xb3,0x2d,0x86,0xba,
                    0x6f,0x4c,0xa7,0xb4,0x4d,0x3f,0xe4,0x85}
    }};

    // Characteristic reflecting key presses.
    // The characteristic is identified within the service by a 16-bit unique ID.
    static simple_ble_char_t key_state_characteristic = {.uuid16 = 0x7182};
    
    static char my_char_data[20];
    //uint8_t Finger_states[4];
=}

 reactor Board (period:time(100 ms)){
    input clck:int;
    input finger1:float;
    input finger2:float;
    input finger3:float;
    input finger4:float;
    input gx:float;
    input gy:float;
    input gz:float;
    input acc_x:float;
    timer t(0, period);
    initial mode INIT {
        reaction(startup) -> LOOP {=
            ret_code_t error_code = NRF_SUCCESS;

            // initialize RTT library
            error_code = NRF_LOG_INIT(NULL);
            APP_ERROR_CHECK(error_code);
            NRF_LOG_DEFAULT_BACKENDS_INIT();
            //printf("Log initialized!\n");

            // setup ble
            simple_ble_app_t* simple_ble_app;
            simple_ble_app = simple_ble_init(&ble_config);
            simple_ble_add_service(&my_service);
            simple_ble_add_characteristic(1,0,1,0,sizeof(my_char_data), (uint8_t*)&my_char_data,&my_service, &key_state_characteristic);
            simple_ble_adv_only_name();

            if (error_code == NRF_SUCCESS) {
                SET_MODE(LOOP);                
            }
        =}
    }
    mode LOOP {
        reaction(clck,finger1,finger2,finger3,finger4,acc_x,gx) {=
            //printf("DEBUG: clck");
            if (finger1->value >-0.5 ) {
                my_char_data[0]=' ';

                
            } if else (finger1->value <= -0.5) {
               
                y_char_data[0]='F';
                my_char_data[1]='i';
                my_char_data[2]='n';
                my_char_data[3]='g';
                my_char_data[4]='e';
                my_char_data[5]='r';
                my_char_data[6]='1';
                my_char_data[7]=' ';
                my_char_data[8]='i';
                my_char_data[9]='s';
                my_char_data[10]=' ';
                my_char_data[11]='b';
                my_char_data[12]='e';
                my_char_data[13]='n';
                my_char_data[14]='d';
                my_char_data[15]='i';
                my_char_data[16]='n';
                my_char_data[17]='g';
                my_char_data[18]='!';
                
            }
            
            //simple_ble_adv_manuf_data((uint8_t*) &Finger_states, sizeof(Finger_states));
        =}
    }
}


/**
 * Create an ArrowKeys reactor that listens for Bluetooth signals
 * reporting when the user presses arrow keys on a computer that is
 * paired with the nRF52 running this program and displays which
 * arrow keys are pressed.
 */
main reactor {
    //arduino = new Arduino();
    timer t(0, 50 msec);
    reaction(t) -> board.clck , glove.trigger{=
        SET(board.clck, 1);
        lf_set(glove.trigger, true);
    =}
    board= new Board ();
    glove = new Glove();
    gyro = new GyroAngle();
    ang = new  Tilt();
    glove.f1->board.finger1;
    glove.f2->board.finger2;
    glove.f3->board.finger3;
    glove.f4->board.finger4;
    
    e1=new ExponentialFilter(); 
    e2=new ExponentialFilter(); 
    e3=new ExponentialFilter(); 
    gyro.x->e1.in;
    gyro.y->e2.in;
    gyro.z->e3.in;
    e1.out -> ang.x;
    e2.out -> ang.y;
    e3.out -> ang.z;
    // reaction(glove.x1) {=
    //     // Print results.
        
    //     printf("x1: %.2lf\n", glove.x1->value);
    // =}
    reaction(ang.pitch, ang.roll,ang.tilt ) {=
        // Print results.

        printf("x: %.2lf\ty: %.2lf\tz:%.2lf\n", ang.pitch->value, ang.roll->value,ang.tilt->value);
    =}
    /*
    display = new Display();
    keys    = new ArrowKeys();

    reaction(keys.up, keys.down, keys.left, keys.right) -> display.message {=
        static char message[5] = "____\0";
        if (keys.up->value) {
            message[0] = 'U';
        } else {
            message[0] = '_';
        }
        if (keys.down->value) {
            message[1] = 'D';
        } else {
            message[1] = '_';
        }
        if (keys.left->value) {
            message[2] = 'L';
        } else {
            message[2] = '_';
        }
        if (keys.right->value) {
            message[3] = 'R';
        } else {
            message[3] = '_';
        }
        lf_set(display.message, message);
    =}
    */
    

}
/////////
// target C {
//     threading: false,
//     build: "../scripts/build_nrf_unix.sh"   
// };
// import Glove from "lib/glove.lf"


// preamble {=
//     #include "simple_ble.h"
//     #include <ble_advdata.h>
//     #include <math.h>
//     #include <stdbool.h>
//     #include <stdint.h>
//     #include <stdio.h>
//     #include "app_error.h"
//     #include "app_timer.h"
//     #include "nrf.h"
//     #include "nrf_delay.h"
//     #include "nrf_gpio.h"
//     #include "nrf_log.h"
//     #include "nrf_log_ctrl.h"
//     #include "nrf_log_default_backends.h"
//     #include "nrf_pwr_mgmt.h"
//     #include "nrf_drv_spi.h"

//     // sensors
//     #define Finger_1 NRF_GPIO_PIN_MAP(0, 13)
//     #define Finger_2 NRF_GPIO_PIN_MAP(0, 14)
//     #define Finger_3 NRF_GPIO_PIN_MAP(0, 15)
//     #define Finger_4 NRF_GPIO_PIN_MAP(0, 16)

    
//     // Data structures needed for BLE.
//     // See https://github.com/lab11/nrf52x-base/blob/master/lib/simple_ble/README.md

//     // BLE Configuration specifies the MAC address and
//     // intervals for advertising and connections.
//     static simple_ble_config_t ble_config = {
//             // MAC address: c0:98:e5:49:xx:xx
//             // where the last two octets are given by the device_id below.
//             .platform_id       = 0x49,   // The 4th octet in device BLE address.
//             .device_id         = 0x0018, // TODO: replace with your lab bench number
//             .adv_name          = "NRF_BOARD", // used in advertisements if there is room
//             .adv_interval      = MSEC_TO_UNITS(100, UNIT_0_625_MS),
//             .min_conn_interval = MSEC_TO_UNITS(100, UNIT_1_25_MS),
//             .max_conn_interval = MSEC_TO_UNITS(200, UNIT_1_25_MS),
//     };

//     // Specify a unique ID for the ROMI service.
//     // UUID: 85e43f4d-b4a7-4c6f-ba86-2db3c40a2c83
//     static simple_ble_service_t my_service = {{
//         .uuid128 = {0x83,0x2c,0x0a,0xc4,0xb3,0x2d,0x86,0xba,
//                     0x6f,0x4c,0xa7,0xb4,0x4d,0x3f,0xe4,0x85}
//     }};

//     // Characteristic reflecting key presses.
//     // The characteristic is identified within the service by a 16-bit unique ID.
//     static simple_ble_char_t key_state_characteristic = {.uuid16 = 0x7182};
    
//     static char my_char_data[20] ;
//     uint8_t Finger_states[4];
// =}

// /**
//  * This reactor, designed to run on an nRF52 board, advertises
//  * itself during startup and adds a Bluetooth service with a
//  * characteristic that receives arrow key information from a
//  * computer that pairs with the nRF52. It then periodically
//  * outputs four booleans indicating whether each particular
//  * arrow key is currently pressed.  The period is given as
//  * a parameter.
//  */

//  reactor Board (period:time(100 ms)){
//     input clck:int;
//     timer t(0, period);
//     initial mode INIT {
//         reaction(startup) -> LOOP {=
//             ret_code_t error_code = NRF_SUCCESS;

//             // initialize RTT library
//             error_code = NRF_LOG_INIT(NULL);
//             APP_ERROR_CHECK(error_code);
//             NRF_LOG_DEFAULT_BACKENDS_INIT();
//             //printf("Log initialized!\n");

//             // initialize pins
//             //nrf_gpio_cfg_output(LED_1);
//             nrf_gpio_cfg_input(Finger_1, NRF_GPIO_PIN_PULLUP);
//             nrf_gpio_cfg_input(Finger_2, NRF_GPIO_PIN_PULLUP);
//             nrf_gpio_cfg_input(Finger_3, NRF_GPIO_PIN_PULLUP);
//             nrf_gpio_cfg_input(Finger_4, NRF_GPIO_PIN_PULLUP);

//             // setup ble
//             simple_ble_app_t* simple_ble_app;
//             simple_ble_app = simple_ble_init(&ble_config);
//             simple_ble_add_service(&my_service);
//             simple_ble_add_characteristic(1,0,1,0,sizeof(my_char_data), (uint8_t*)&my_char_data,&my_service, &key_state_characteristic);
//             simple_ble_adv_only_name();

//             if (error_code == NRF_SUCCESS) {
//                 SET_MODE(LOOP);                
//             }
//         =}
//     }
//     mode LOOP {
//         reaction(clck) {=
//             //printf("DEBUG: clck");
//             Finger_states[0] = nrf_gpio_pin_read(Finger_1);
//             Finger_states[1] = nrf_gpio_pin_read(Finger_2);
//             Finger_states[2] = nrf_gpio_pin_read(Finger_3);
//             Finger_states[3] = nrf_gpio_pin_read(Finger_4);
//             if (Finger_states[0]) {
//                 my_char_data[0]='s';
//             } else {
//                 my_char_data[0]='f';
//             }
//             simple_ble_adv_manuf_data((uint8_t*) &Finger_states, sizeof(Finger_states));
//         =}
//     }
// }


// /**
//  * Create an ArrowKeys reactor that listens for Bluetooth signals
//  * reporting when the user presses arrow keys on a computer that is
//  * paired with the nRF52 running this program and displays which
//  * arrow keys are pressed.
//  */
// main reactor {
//     //arduino = new Arduino();
//     timer t(0, 50 msec);
//     reaction(t) -> board.clck , glove.trigger{=
//         SET(board.clck, 1);
//         lf_set(glove.trigger, true);
//     =}
//     board= new Board ();
//     glove = new Glove();
    
    
//     reaction(glove.x1) {=
//         // Print results.
        
//         printf("x1: %.2lf\n", glove.x1->value);
//     =}
//     /*
//     display = new Display();
//     keys    = new ArrowKeys();

//     reaction(keys.up, keys.down, keys.left, keys.right) -> display.message {=
//         static char message[5] = "____\0";
//         if (keys.up->value) {
//             message[0] = 'U';
//         } else {
//             message[0] = '_';
//         }
//         if (keys.down->value) {
//             message[1] = 'D';
//         } else {
//             message[1] = '_';
//         }
//         if (keys.left->value) {
//             message[2] = 'L';
//         } else {
//             message[2] = '_';
//         }
//         if (keys.right->value) {
//             message[3] = 'R';
//         } else {
//             message[3] = '_';
//         }
//         lf_set(display.message, message);
//     =}
//     */
    

// }
