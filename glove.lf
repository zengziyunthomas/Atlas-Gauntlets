 target C;

 preamble {=
     #include "nrfx_gpiote.h"
     #include "nrfx_saadc.h"
     #include "buckler.h"        // Defines BUCKLER_ANALOG_ACCEL_...
     
     // ADC channels
     #define AC_CHANNEL 0
     #define F1_CHANNEL 1
     #define F2_CHANNEL 2
     #define F3_CHANNEL 3
     #define F4_CHANNEL 4
     /**
      * NRF ADC Constants
      * gain is 1/6 and scales the input voltage. 
      * internal reference voltage is 0.6; the voltage range is 0-0.6
      * effective range before gain is 3.6
      * adc resolution is 12 bits; 2^12 = 4096 
      */
      #define FSR 3.6
      #define LSB FSR / 4096
 
     /**
      * ADXL327 Constants.
      * Bias and sensitivity are ratiometric.
      * They are proportional to the supply voltage which might be less than 3V.
      * They can further adjusted using the bias and sensitivity parameters.
      */
     #define VSS 2.98
     #define ADXL327_BIAS 1.5 * (VSS / 3.0)
     #define ADXL327_SENS 0.42 * (VSS / 3.0)
 
     // callback for SAADC events
     void saadc_callback (nrfx_saadc_evt_t const * p_event) {
         // Ignore ADC callbacks.
     }
     
     // Sample a particular analog channel in blocking mode
     nrf_saadc_value_t sample_value(uint8_t channel) {
         nrf_saadc_value_t val;
         ret_code_t error_code = nrfx_saadc_sample_convert(channel, &val);
         APP_ERROR_CHECK(error_code);
         return val;
     }
     
     // Global variable to prevent initializing more than once.
     bool buckler_glove = false;
 
 =}
 
 /**
  * Reactor that, when triggered, outputs the x, y, and z axis readings in g's
  * of the analog accelerometer on the Buckler board.
  * The bias and sensitivity need to be determined experimentally.
  */
 reactor Glove(bias:float(0.0), sensitivity:float(1)) {
     input trigger:bool;
     output x:float;
     output f1:float;
     output f2:float;
     output f3:float;
     output f4:float;
     
     reaction(startup) {=
         if (buckler_glove) return;
         buckler_glove = true;
         
         // initialize analog to digital converter
         nrfx_saadc_config_t saadc_config = NRFX_SAADC_DEFAULT_CONFIG;
         saadc_config.resolution = NRF_SAADC_RESOLUTION_12BIT;
         ret_code_t error_code = nrfx_saadc_init(&saadc_config, saadc_callback);
         APP_ERROR_CHECK(error_code);
     
         // initialize analog inputs
         // configure with 0 as input pin for now
         nrf_saadc_channel_config_t channel_config = NRFX_SAADC_DEFAULT_CHANNEL_CONFIG_SE(0);
         channel_config.gain = NRF_SAADC_GAIN1_6;
         channel_config.reference = NRF_SAADC_REFERENCE_INTERNAL;
     
         // specify input pin and initialize that ADC channel


         channel_config.pin_p = BUCKLER_ANALOG_ACCEL_X;
         error_code = nrfx_saadc_channel_init(AC_CHANNEL, &channel_config);
         APP_ERROR_CHECK(error_code);
     
         // specify input pin and initialize that ADC channel
         channel_config.pin_p = BUCKLER_ANALOG_ACCEL_Y;
         error_code = nrfx_saadc_channel_init(F1_CHANNEL, &channel_config);
         APP_ERROR_CHECK(error_code);
     
         //specify input pin and initialize that ADC channel
         channel_config.pin_p = BUCKLER_ANALOG_ACCEL_Z;
         error_code = nrfx_saadc_channel_init(F2_CHANNEL, &channel_config);
         APP_ERROR_CHECK(error_code);

         //specify input pin and initialize that ADC channel
         channel_config.pin_p = NRF_SAADC_INPUT_AIN4;
         error_code = nrfx_saadc_channel_init(F3_CHANNEL, &channel_config);
         APP_ERROR_CHECK(error_code);
         //specify input pin and initialize that ADC channel
         channel_config.pin_p = NRF_SAADC_INPUT_AIN3;
         error_code = nrfx_saadc_channel_init(F4_CHANNEL, &channel_config);
         APP_ERROR_CHECK(error_code);
     =}
     reaction(trigger) -> x,f1,f2,f3,f4 {=
         nrf_saadc_value_t x_raw;
         if (trigger->value) {
            // Sample analog inputs.
             x_raw = sample_value(AC_CHANNEL);
             f1_raw = sample_value(F1_CHANNEL);
             f2_raw = sample_value(F2_CHANNEL);
             f3_raw = sample_value(F3_CHANNEL);
             f4_raw = sample_value(F4_CHANNEL);
             
             float bias = self->bias + ADXL327_BIAS;
             float sensitivity = self->sensitivity * ADXL327_SENS;
             
             lf_set(x, ((x_raw * LSB) - bias) / sensitivity);
             //lf_set(x1,x_raw);
             lf_set(f1, ((f1_raw * LSB) - bias) / sensitivity);
             lf_set(f2, ((f2_raw * LSB) - bias) / sensitivity);
             lf_set(f3, ((f3_raw * LSB) - bias) / sensitivity);
             lf_set(f4, ((f4_raw * LSB) - bias) / sensitivity);
         }
     =}
 }
 